# test-spectrogram_cutoff.R
library(testthat)
library(seewave)
library(tuneR)
library(viridis)
library(ggplot2)
library(RthopteraSounds)

data("coryphoda")
wave_mono <- coryphoda
class(wave_mono)

test_that("spectrogram_cutoff generates matrix with correct cutoff and
          no plot", {
  # Run without plot, cutoff at -60
  result <- spectrogram_cutoff(wave_mono, cutoff = -60, plot = FALSE)

  # Test that result is a matrix
  expect_true(is.matrix(result))

  # Check that values below the cutoff are NA
  expect_true(all(result[result < -60] == NA, na.rm = TRUE))
})

test_that("spectrogram_cutoff generates matrix with noise reduction for rows", {
  result <- spectrogram_cutoff(wave_mono, noise.red = "rows", plot = FALSE)

  # Test that result is a matrix
  expect_true(is.matrix(result))

  # Ensure noise reduction did not crash the function
  expect_true(!is.null(result))
})

test_that("spectrogram_cutoff handles noise reduction for columns", {
  result <- spectrogram_cutoff(wave_mono, noise.red = "cols", plot = FALSE)

  # Ensure matrix is returned
  expect_true(is.matrix(result))
})

test_that("spectrogram_cutoff raises error for invalid noise.red option", {
  # Expect error for invalid noise.red argument
  expect_error(spectrogram_cutoff(wave_mono, noise.red = "invalid"), "noise.red should be 'rows', 'columns', or 'NULL'")
})

test_that("spectrogram_cutoff supports various bit depths and converts to dBFS correctly", {
  # Generate synthetic Wave objects at different bit depths
  wave_16 <- synth(d = 1, f = 44100, cf = 440, bit = 16, output = "Wave")
  wave_24_mc <- synth(d = 1, f = 44100, cf = 440, bit = 24, output = "Wave")
  wave_32_mc <- synth(d = 1, f = 44100, cf = 440, bit = 32, output = "Wave")

  # Convert to single-channel Wave if generated as WaveMC
  wave_24 <- if (inherits(wave_24_mc, "WaveMC")) tuneR::channel(wave_24_mc, "left") else wave_24_mc
  wave_32 <- if (inherits(wave_32_mc, "WaveMC")) tuneR::channel(wave_32_mc, "left") else wave_32_mc

  # Confirm each object is of class Wave
  expect_s4_class(wave_16, "Wave")
  expect_s4_class(wave_24, "Wave")
  expect_s4_class(wave_32, "Wave")

  # Run spectrogram_cutoff on each Wave object
  result_16 <- spectrogram_cutoff(wave_16, cutoff = -40, plot = FALSE)
  result_24 <- spectrogram_cutoff(wave_24, cutoff = -40, plot = FALSE)
  result_32 <- spectrogram_cutoff(wave_32, cutoff = -40, plot = FALSE)

  # Verify that the results are matrices and are not NULL
  expect_true(is.matrix(result_16))
  expect_true(is.matrix(result_24))
  expect_true(is.matrix(result_32))
})


test_that("spectrogram_cutoff plots with ggplot and base R", {
  # ggplot = TRUE (default)
  result <- spectrogram_cutoff(wave_mono, plot = TRUE, ggplot = TRUE, plot.title = "Test Plot GG")
  expect_true("ggplot" %in% class(result$plot))

  # ggplot = FALSE (base R plot)
  result_base <- spectrogram_cutoff(wave_mono, plot = TRUE, ggplot = FALSE, plot.title = "Test Plot Base R")

  # Verify that the result is a matrix and no plot object is returned
  expect_true(is.matrix(result_base))  # Should be matrix only with no $plot element

  # Check that a plot was actually generated by checking for an active plotting device
  expect_true(dev.cur() > 1)  # dev.cur() returns >1 if there's an open graphics device

  # Close the plotting device after the test to clean up
  dev.off()
})



test_that("spectrogram_cutoff uses correct window length for different frequency resolutions", {
  # Frequency resolution resulting in even window length
  result_even <- spectrogram_cutoff(wave_mono, freq.res = 100, plot = FALSE)

  # Frequency resolution resulting in odd window length, should be adjusted
  result_odd <- spectrogram_cutoff(wave_mono, freq.res = 99, plot = FALSE)

  # Both should be matrices
  expect_true(is.matrix(result_even))
  expect_true(is.matrix(result_odd))
})
